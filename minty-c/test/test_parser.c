#include <stdio.h>
#include <malloc.h>
#include "minunit.h"
#include "../minty_util.h"
#include "../token.h"
#include "../lexer.h"
#include "../parser.h"
#include "../AST.h"

int tests_run = 0;

/*
 * Tests the AST equality checking function by asserting that a parsed AST for
 * the program:
 *
 * fn main() {return 0;}
 *
 * is not equal to a hand-built AST representing the (semantically invalid, but
 * syntactically valid) program:
 *
 * fn main() {print hello;}
 */
char *test_tiny_prog_diff() {

	LinkedList *prog_tokens = lex("fn main() {return 0;}");

	Program *parsed_prog = parse_program(prog_tokens);

	// AST that should NOT return true when compared to the above AST
	LinkedList *stmts = LinkedList_init();
	LinkedList_append(stmts, Print_init(Identifier_init(safe_strdup("hello"))));
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(safe_strdup("main"),
		LinkedList_init(), stmts));
	Program *ast = Program_init(fns);

	// Assert that the two ASTs are the same
	mu_assert(!Program_equals(parsed_prog, ast), "test_tiny_prog_diff failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free(LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that the simple program:
 *
 * fn main() {return 0;}
 *
 * is parsed correcly by comparing it to a hand-built AST representing the same
 * program
 */
char *test_tiny_prog_same() {

	LinkedList *prog_tokens = lex("fn main() {return 0;}");

	Program *parsed_prog = parse_program(prog_tokens);

	// AST representing the AST that should be generated by the call to
	// parse_program above
	LinkedList *stmts = LinkedList_init();
	LinkedList_append(stmts, Return_init(IntegerLiteral_init(0)));
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(safe_strdup("main"),
		LinkedList_init(), stmts));
	Program *ast = Program_init(fns);

	// Assert that the two ASTs are the same
	mu_assert(Program_equals(parsed_prog, ast), "test_tiny_prog_same failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free(LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that the program shown in the test below is parsed correctly by
 * comparing it to a hand-build AST representing the same program
 */
char *test_two_functions() {

	LinkedList *prog_tokens = lex("    \
		fn main() {                    \
			return binary_add(4, 5);   \
		}                              \
		fn binary_add(num1, num2) {    \
			return num1 + num2;        \
		}");

	Program *parsed_prog = parse_program(prog_tokens);

	// main function
	LinkedList *caller_args = LinkedList_init();
	LinkedList_append(caller_args, IntegerLiteral_init(4));
	LinkedList_append(caller_args, IntegerLiteral_init(5));
	LinkedList *main_stmts = LinkedList_init();
	LinkedList_append(main_stmts, Return_init(
		FNCall_init(safe_strdup("binary_add"), caller_args)));
	FNDecl *main_fn = FNDecl_init(
		safe_strdup("main"),
		LinkedList_init(),
		main_stmts);

	// binary_add function
	LinkedList *callee_args = LinkedList_init();
	LinkedList_append(callee_args, safe_strdup("num1"));
	LinkedList_append(callee_args, safe_strdup("num2"));
	LinkedList *binary_add_stmts = LinkedList_init();
	LinkedList_append(binary_add_stmts, Return_init(
		ArithmeticExpr_init(
			Identifier_init(safe_strdup("num1")),
			PLUS,
			Identifier_init(safe_strdup("num2")))));
	FNDecl *binary_add_fn = FNDecl_init(
		safe_strdup("binary_add"),
		callee_args,
		binary_add_stmts);

	// Program object
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, main_fn);
	LinkedList_append(fns, binary_add_fn);
	Program *ast = Program_init(fns);

	// Make the assertion
	mu_assert(Program_equals(parsed_prog, ast), "test_two_functions failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free((Token *)LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that the program shown in the test below is parsed correctly by
 * comparing it to a hand-build AST representing the same program
 */
char *test_big_expression() {

	LinkedList *prog_tokens = lex(
		"fn main() {return 1 - 2 + 3 < 4 ? 1 : 2 * 2 / 7 % 6;}");

	Program *parsed_prog = parse_program(prog_tokens);

	// Hand-built AST:
	LinkedList *stmts = LinkedList_init();
	Statement* ret = Return_init(
			ArithmeticExpr_init(
				IntegerLiteral_init(1),
				MINUS,
				ArithmeticExpr_init(
					IntegerLiteral_init(2),
					PLUS,
					Ternary_init(
						BooleanExpr_init(
							IntegerLiteral_init(3),
							LESS_THAN,
							IntegerLiteral_init(4)),
						IntegerLiteral_init(1),
						ArithmeticExpr_init(
							IntegerLiteral_init(2),
							MULTIPLY,
							ArithmeticExpr_init(
								IntegerLiteral_init(2),
								DIVIDE,
								ArithmeticExpr_init(
									IntegerLiteral_init(7),
									MODULO,
									IntegerLiteral_init(6)
								)
							)
						)
					)
				)
			)
		);
	LinkedList_append(stmts, ret);
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(
		safe_strdup("main"),
		LinkedList_init(),
		stmts));
	Program *ast = Program_init(fns);

	// Print the generated & built expressions just for fun
	// char *parsed_prog_str = Expression_str(((Statement *)LinkedList_get((
	// 	(FNDecl *)LinkedList_get(parsed_prog->function_list, 0))->stmts,
	// 	0))->stmt->_return->expr);
	// char *hand_build_str = Expression_str(ret->stmt->_return->expr);
	// printf("%s\n", parsed_prog_str);
	// printf("%s\n", hand_build_str);
	// free(parsed_prog_str);
	// free(hand_build_str);

	// Make the assertion
	mu_assert(Program_equals(parsed_prog, ast), "test_big_expression failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free((Token *)LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that bracketing is handled correctly by the parser
 */
char *test_brackets() {

	LinkedList *prog_tokens = lex(
		"fn main() {return ((7 - 2) * (20 / 4)) % 2;}");

	Program *parsed_prog = parse_program(prog_tokens);

	// Hand-built AST:
	LinkedList *stmts = LinkedList_init();
	Statement* ret =
		Return_init(
			ArithmeticExpr_init(
				ArithmeticExpr_init(
					ArithmeticExpr_init(
						IntegerLiteral_init(7),
						MINUS,
						IntegerLiteral_init(2)
					),
					MULTIPLY,
					ArithmeticExpr_init(
						IntegerLiteral_init(20),
						DIVIDE,
						IntegerLiteral_init(4)
					)
				),
				MODULO,
				IntegerLiteral_init(2)
			)
		);
	LinkedList_append(stmts, ret);
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(
		safe_strdup("main"),
		LinkedList_init(),
		stmts));
	Program *ast = Program_init(fns);

	// Print the generated & built expressions just for fun
	// char *parsed_prog_str = Expression_str(((Statement *)LinkedList_get((
	// 	(FNDecl *)LinkedList_get(parsed_prog->function_list, 0))->stmts,
	// 	0))->stmt->_return->expr);
	// char *hand_build_str = Expression_str(ret->stmt->_return->expr);
	// printf("%s\n", parsed_prog_str);
	// printf("%s\n", hand_build_str);
	// free(parsed_prog_str);
	// free(hand_build_str);

	// Make the assertion
	mu_assert(Program_equals(parsed_prog, ast), "test_brackets failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free((Token *)LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that a program with a for-loop is parsed correctly
 */
char *test_for_loop() {

	LinkedList *prog_tokens = lex("              \
		fn main() {                              \
			for i <- 20, i < 30, i <- i + 1 {    \
				print i;                         \
			}                                    \
			return 999;                          \
		}");

	Program *parsed_prog = parse_program(prog_tokens);

	// Hand-built AST:
	LinkedList *stmts = LinkedList_init();
	LinkedList *for_stmts = LinkedList_init();
	LinkedList_append(for_stmts, Print_init(Identifier_init(safe_strdup("i"))));
	LinkedList_append(stmts,
		For_init(
			Assignment_init(
				safe_strdup("i"),
				IntegerLiteral_init(20)
			),
			BooleanExpr_init(
				Identifier_init(
					safe_strdup("i")
				),
				LESS_THAN,
				IntegerLiteral_init(30)
			),
			Assignment_init(
				safe_strdup("i"),
				ArithmeticExpr_init(
					Identifier_init(
						safe_strdup("i")
					),
					PLUS,
					IntegerLiteral_init(1)
				)
			),
			for_stmts
		)
	);
	LinkedList_append(stmts, Return_init(IntegerLiteral_init(999)));
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(
		safe_strdup("main"),
		LinkedList_init(),
		stmts));
	Program *ast = Program_init(fns);

	// Make the assertion
	mu_assert(Program_equals(parsed_prog, ast), "test_for_loop failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free((Token *)LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

/*
 * Tests that a program with a for-loop is parsed correctly
 */
char *test_while_loop() {

	LinkedList *prog_tokens = lex("\
		fn main(num) {             \
			while(num < 10) {      \
				print num;         \
			}                      \
			return 0;              \
		}");

	Program *parsed_prog = parse_program(prog_tokens);

	// Hand-built AST:
	LinkedList *stmts = LinkedList_init_with(
		While_init(
			BooleanExpr_init(
				Identifier_init(
					safe_strdup("num")
				),
				LESS_THAN,
				IntegerLiteral_init(10)
			),
			LinkedList_init_with((void *)
				Print_init(Identifier_init(safe_strdup("num"))))
		)
	);
	LinkedList_append(stmts, Return_init(IntegerLiteral_init(0)));
	LinkedList *fns = LinkedList_init();
	LinkedList_append(fns, FNDecl_init(
		safe_strdup("main"),
		LinkedList_init_with(safe_strdup("num")),
		stmts));
	Program *ast = Program_init(fns);

	// Make the assertion
	mu_assert(Program_equals(parsed_prog, ast), "test_while_loop failed!");

	// Free things
	int i;
	for(i = 0; i < LinkedList_length(prog_tokens); i++)
		Token_free((Token *)LinkedList_get(prog_tokens, i));
	LinkedList_free(prog_tokens);
	Program_free(parsed_prog);
	Program_free(ast);

	return NULL;
}

char *all_tests() {

	mu_suite_start();
	
	mu_run_test(test_tiny_prog_same);
	mu_run_test(test_tiny_prog_diff);
	mu_run_test(test_two_functions);
	mu_run_test(test_big_expression);
	mu_run_test(test_brackets);
	mu_run_test(test_for_loop);
	mu_run_test(test_while_loop);

	return NULL;
}

RUN_TESTS(all_tests);